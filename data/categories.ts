import { databases, ID, Query, storage } from '@/lib/appwrite-server';

export async function createCategory(name: string, imageUrl?: string) {
  // Appwrite will automatically generate the unique ID
  return await databases.createDocument(
    process.env.NEXT_PRIVATE_DATABASE_ID!,
    process.env.NEXT_PRIVATE_CATEGORY_COLLECTION_ID!,
    ID.unique(), // This is auto-generated by Appwrite
    {
      name: name.trim(),
      image: imageUrl || null,
    }
  );
}

export async function getCategories() {
  try {
    const result = await databases.listDocuments(
      process.env.NEXT_PRIVATE_DATABASE_ID!,
      process.env.NEXT_PRIVATE_CATEGORY_COLLECTION_ID!
    );
    return result.documents;
  } catch (error) {
    console.error('Error fetching categories:', error);
    return [];
  }
}

export async function getCategoryByName(name: string) {
  try {
    const result = await databases.listDocuments(
      process.env.NEXT_PRIVATE_DATABASE_ID!,
      process.env.NEXT_PRIVATE_CATEGORY_COLLECTION_ID!,
      [Query.equal('name', name)]
    );
    return result.documents[0] || null;
  } catch (error) {
    console.error('Error fetching category by name:', error);
    return null;
  }
}

export async function getCategoryById(categoryId: string) {
  try {
    return await databases.getDocument(
      process.env.NEXT_PRIVATE_DATABASE_ID!,
      process.env.NEXT_PRIVATE_CATEGORY_COLLECTION_ID!,
      categoryId
    );
  } catch (error) {
    console.error('Error fetching category by ID:', error);
    return null;
  }
}

export async function updateCategory(categoryId: string, updates: { name?: string; image?: string }) {
  return await databases.updateDocument(
    process.env.NEXT_PRIVATE_DATABASE_ID!,
    process.env.NEXT_PRIVATE_CATEGORY_COLLECTION_ID!,
    categoryId,
    updates
  );
}

export async function deleteCategory(categoryId: string) {
  return await databases.deleteDocument(
    process.env.NEXT_PRIVATE_DATABASE_ID!,
    process.env.NEXT_PRIVATE_CATEGORY_COLLECTION_ID!,
    categoryId
  );
}

// Upload image to Appwrite storage
export async function uploadImage(file: File): Promise<string> {
  try {    
    const uploadedFile = await storage.createFile(
      process.env.NEXT_PUBLIC_BUCKET_ID!,
      ID.unique(), // Auto-generated file ID
      file
    );

    // Generate the proper image URL format
    const endpoint = process.env.NEXT_PUBLIC_APPWRITE_ENDPOINT!;
    const projectId = process.env.NEXT_PUBLIC_APPWRITE_PROJECT_ID!;
    const bucketId = process.env.NEXT_PUBLIC_BUCKET_ID!;
    
    return `${endpoint}/storage/buckets/${bucketId}/files/${uploadedFile.$id}/view?project=${projectId}`;
  } catch (error) {
    console.error('Error uploading image:', error);
    throw new Error('Failed to upload image');
  }
}

// Delete image from storage when category is deleted
export async function deleteImage(fileId: string) {
  try {
    await storage.deleteFile(
      process.env.NEXT_PUBLIC_BUCKET_ID!,
      fileId
    );
  } catch (error) {
    console.error('Error deleting image:', error);
  }
}


// Add this function to your existing data/categories.ts file
export async function getCategoryByIdFormatted(categoryId: string) {
  try {
    const category = await databases.getDocument(
      process.env.NEXT_PRIVATE_DATABASE_ID!,
      process.env.NEXT_PRIVATE_CATEGORY_COLLECTION_ID!,
      categoryId
    );
    
    // Format the category to match our expected type
    return {
      $id: category.$id,
      name: category.name,
      image: category.image || undefined
    };
  } catch (error) {
    console.error('Error fetching category by ID:', error);
    return null;
  }
}